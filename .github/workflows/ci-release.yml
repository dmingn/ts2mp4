name: CI and Release

on:
  push:
    branches: [master]
    tags: ["*"]
  pull_request:
    branches: ["**"]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4.2.2

      - name: Install poetry
        run: pipx install poetry

      - name: Set up Python
        uses: actions/setup-python@v5.6.0
        with:
          python-version-file: ".python-version"
          cache: "poetry"

      - name: Check lock file consistency
        run: poetry check --lock

      - name: Install dependencies
        run: poetry sync

      - name: Install ffmpeg
        run: sudo apt-get update && sudo apt-get install -y ffmpeg

      - name: Run all checks
        run: make check

  validate_release_tag:
    runs-on: ubuntu-latest
    outputs:
      is_valid_tag: ${{ steps.check_tag.outputs.is_valid_tag }}
    if: startsWith(github.ref, 'refs/tags/') # Only run if it's a tag push
    steps:
      - name: Check tag format
        id: check_tag
        run: |
          TAG_NAME=${{ github.ref }}
          TAG_VERSION=$(echo $TAG_NAME | sed 's/^refs\/tags\///') # Remove refs/tags/

          if [[ "$TAG_VERSION" =~ ^[0-9]{4}\.[0-9]{2}\.[0-9]{2}\.[0-9]+$ ]]; then
            echo "Tag format is valid: $TAG_VERSION"
            echo "is_valid_tag=true" >> $GITHUB_OUTPUT
          else
            echo "Tag format is invalid: $TAG_VERSION. Expected YYYY.MM.DD.X format."
            echo "is_valid_tag=false" >> $GITHUB_OUTPUT
          fi

  release:
    needs: [build, validate_release_tag]
    runs-on: ubuntu-latest
    if: needs.validate_release_tag.outputs.is_valid_tag == 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4.2.2

      - name: Validate pyproject.toml version
        id: validate_version
        run: |
          TAG_NAME=${{ github.ref }}
          TAG_VERSION=$(echo $TAG_NAME | sed 's/^refs\/tags\///') # Remove refs/tags/

          # Extract version from pyproject.toml using grep and sed
          PYPROJECT_VERSION=$(grep '^version = ' pyproject.toml | sed -E 's/version = "(.*)"/\1/')

          echo "Tag version: $TAG_VERSION"
          echo "pyproject.toml version: $PYPROJECT_VERSION"

          if [ "$TAG_VERSION" != "$PYPROJECT_VERSION" ]; then
            echo "Error: Tag version ($TAG_VERSION) does not match pyproject.toml version ($PYPROJECT_VERSION)."
            exit 1
          fi
          echo "Tag and pyproject.toml versions match."
          echo "release_version=$TAG_VERSION" >> $GITHUB_OUTPUT

      - name: Create GitHub Release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          TAG_NAME=${{ github.ref }}
          RELEASE_NAME="Release ${{ steps.validate_version.outputs.release_version }}"

          gh release create "$TAG_NAME" \
            --generate-notes \
            --draft=false \
            --prerelease=false

  propose-version-update:
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/master' && github.event_name == 'push'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4.2.2

      - name: Install poetry
        run: pipx install poetry

      - name: Update version if needed
        id: update_version
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Get the latest release version from GitHub
          LATEST_GH_RELEASE=$(gh release list --limit 1 --json tagName --jq '.[0].tagName' || echo "")

          TODAY=$(date +'%Y.%m.%d')

          if [[ -z "$LATEST_GH_RELEASE" ]]; then
            echo "No releases found. Starting with version $TODAY.0"
            POTENTIAL_NEW_VERSION="$TODAY.0"
          else
            echo "Latest GitHub release is $LATEST_GH_RELEASE"
            LATEST_RELEASE_DATE=$(echo $LATEST_GH_RELEASE | cut -d. -f1-3)
            LATEST_RELEASE_PATCH=$(echo $LATEST_GH_RELEASE | cut -d. -f4)

            if [[ "$LATEST_RELEASE_DATE" < "$TODAY" ]]; then
              POTENTIAL_NEW_VERSION="$TODAY.0"
            else # LATEST_RELEASE_DATE == TODAY
              NEW_PATCH=$((LATEST_RELEASE_PATCH + 1))
              POTENTIAL_NEW_VERSION="$TODAY.$NEW_PATCH"
            fi
          fi

          echo "Potential new version is $POTENTIAL_NEW_VERSION"

          CURRENT_VERSION_IN_CODE=$(poetry version --short)
          echo "Current version in pyproject.toml is $CURRENT_VERSION_IN_CODE"

          if [[ "$POTENTIAL_NEW_VERSION" != "$CURRENT_VERSION_IN_CODE" ]]; then
            echo "Version requires update. Proposing version $POTENTIAL_NEW_VERSION"
            poetry version $POTENTIAL_NEW_VERSION
            echo "version_updated=true" >> $GITHUB_OUTPUT
            echo "new_version=$POTENTIAL_NEW_VERSION" >> $GITHUB_OUTPUT
          else
            echo "Version is already correct: $CURRENT_VERSION_IN_CODE"
            echo "version_updated=false" >> $GITHUB_OUTPUT
          fi

      - name: Create Pull Request
        if: steps.update_version.outputs.version_updated == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          BRANCH_NAME="feature/auto-version-update"
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

          # Create or update the branch
          git checkout -B "$BRANCH_NAME"
          git add pyproject.toml
          git commit -m "build: update version to ${{ steps.update_version.outputs.new_version }}"
          git push --force-with-lease origin "$BRANCH_NAME"

          # Check if a PR already exists for this branch
          if gh pr view "$BRANCH_NAME" >/dev/null 2>&1; then
            echo "Pull request for branch '$BRANCH_NAME' already exists. It has been updated."
          else
            echo "Creating a new pull request for branch '$BRANCH_NAME'."
            gh pr create \
              --title "build: Propose version update to ${{ steps.update_version.outputs.new_version }}" \
              --body "This PR proposes an update to the project version." \
              --head "$BRANCH_NAME" \
              --base "master"
          fi
